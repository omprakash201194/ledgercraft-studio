import React, { useState, useEffect, useCallback } from 'react';
import {
    Box,
    Typography,
    Paper,
    Button,
    TextField,
    MenuItem,
    Switch,
    FormControlLabel,
    IconButton,
    Fade,
    Alert,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    CircularProgress,
    Chip,
    useTheme,
    alpha,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    InputAdornment

} from '@mui/material';
import {
    Add as AddIcon,
    Delete as DeleteIcon,
    ArrowBack as BackIcon,
    Close as CloseIcon,
    Save as SaveIcon,
    ExpandMore as ExpandMoreIcon,
    Tune as TuneIcon
} from '@mui/icons-material';
import CategoryTree from './CategoryTree'; // Assuming it's in the same directory or accessible

// ─── Types ───────────────────────────────────────────────

interface FormatOptions {
    dateFormat?: 'DD-MM-YYYY' | 'MM-DD-YYYY' | 'YYYY-MM-DD';
    decimals?: number;
    currencySymbol?: string;
    transform?: 'uppercase' | 'lowercase';
    prefix?: string;
    suffix?: string;
}

interface FieldDraft {
    id: number;
    label: string;
    field_key?: string; // For editing existing fields
    data_type: string;
    required: boolean;
    placeholder_mapping: string;
    options_csv: string;
    format_options?: FormatOptions | null; // NEW: Formatting configuration
}

interface TemplateRecord {
    id: string;
    name: string;
    placeholder_count: number;
}

interface TemplatePlaceholder {
    id: string;
    template_id: string;
    placeholder_key: string;
}

interface FormWizardProps {
    open: boolean;
    onClose: () => void;
    onSuccess: () => void;
    editFormId?: string | null; // If present, we are in Edit mode
    initialCategoryId?: string | null;
}

const FIELD_TYPES = [
    { value: 'text', label: 'Text' },
    { value: 'number', label: 'Number' },
    { value: 'date', label: 'Date' },
    { value: 'currency', label: 'Currency' },
    { value: 'dropdown', label: 'Dropdown' },
    { value: 'checkbox', label: 'Checkbox' },
    { value: 'multiline', label: 'Multi-line Text' },
];

const DATE_FORMATS = [
    { value: 'DD-MM-YYYY', label: 'DD-MM-YYYY (15-01-2024)' },
    { value: 'MM-DD-YYYY', label: 'MM-DD-YYYY (01-15-2024)' },
    { value: 'YYYY-MM-DD', label: 'YYYY-MM-DD (2024-01-15)' },
];

const TEXT_TRANSFORMS = [
    { value: '', label: 'None' },
    { value: 'uppercase', label: 'UPPERCASE' },
    { value: 'lowercase', label: 'lowercase' },
];

/** Convert label to snake_case field key */
function toFieldKey(label: string): string {
    return label
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '_');
}

let nextFieldId = 1;

const FormWizard: React.FC<FormWizardProps> = ({ open, onClose, onSuccess, editFormId, initialCategoryId }) => {
    const theme = useTheme();

    // ─── State ───────────────────────────────────────────
    const [step, setStep] = useState(1);
    const [loading, setLoading] = useState(false);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState('');

    // Form Data
    const [formName, setFormName] = useState('');
    const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(initialCategoryId || null);
    const [selectedTemplateId, setSelectedTemplateId] = useState('');
    const [fields, setFields] = useState<FieldDraft[]>([]);

    // Resources
    const [templates, setTemplates] = useState<TemplateRecord[]>([]);
    const [placeholders, setPlaceholders] = useState<TemplatePlaceholder[]>([]);

    // ─── Initialization ──────────────────────────────────

    // Load templates on mount
    useEffect(() => {
        if (open) {
            loadTemplates();
        }
    }, [open]);

    // Load form data if editing
    useEffect(() => {
        if (open && editFormId) {
            loadFormDetails(editFormId);
        } else if (open && !editFormId) {
            // Reset for create mode
            setStep(1);
            setFormName('');
            setSelectedCategoryId(initialCategoryId || null);
            setSelectedTemplateId('');
            setFields([]);
            setPlaceholders([]);
            setError('');
        }
    }, [open, editFormId, initialCategoryId]);

    // Auto-generate fields when template changes (Create Mode)
    const [autoGenerated, setAutoGenerated] = useState(false);

    useEffect(() => {
        if (selectedTemplateId) {
            loadPlaceholders(selectedTemplateId);

            if (!editFormId) {
                // Auto-generate fields
                generateFields(selectedTemplateId);
            }
        } else {
            setPlaceholders([]);
            if (!editFormId) setFields([]);
        }
    }, [selectedTemplateId]);

    const generateFields = async (templateId: string) => {
        try {
            setLoading(true);
            const generated = await window.api.generateFormFields(templateId);

            const newFields: FieldDraft[] = generated.map((gf, index) => ({
                id: Date.now() + index,
                label: gf.label,
                field_key: gf.field_key,
                data_type: gf.data_type,
                required: gf.required,
                placeholder_mapping: gf.placeholder_mapping || '',
                options_csv: '',
                format_options: null, // Initialize with null
            }));

            setFields(newFields);
            setAutoGenerated(true);
        } catch (err) {
            console.error('Failed to generate fields', err);
        } finally {
            setLoading(false);
        }
    };

    const loadTemplates = async () => {
        try {
            // Fetch all templates for the dropdown (limit 1000 for now)
            const result = await window.api.getTemplates(1, 1000);
            setTemplates(result.templates);
        } catch (err) {
            console.error('Failed to load templates', err);
        }
    };

    const loadPlaceholders = async (templateId: string) => {
        try {
            const result = await window.api.getTemplatePlaceholders(templateId);
            setPlaceholders(result);
        } catch (err) {
            console.error('Failed to load placeholders', err);
        }
    };

    const loadFormDetails = async (id: string) => {
        setLoading(true);
        try {
            const [form, dbFields] = await Promise.all([
                window.api.getFormById(id),
                window.api.getFormFields(id)
            ]);

            if (form) {
                setFormName(form.name);
                setSelectedCategoryId(form.category_id || null);
                setSelectedTemplateId(form.template_id);

                // Map db fields to drafts
                const draftedFields: FieldDraft[] = dbFields.map(f => ({
                    id: nextFieldId++,
                    label: f.label,
                    field_key: f.field_key,
                    data_type: f.data_type,
                    required: f.required === 1,
                    placeholder_mapping: f.placeholder_mapping || '',
                    options_csv: f.options_json ? (JSON.parse(f.options_json) as string[]).join(', ') : '',
                    format_options: f.format_options ? JSON.parse(f.format_options) : null, // NEW: Parse format_options
                }));
                setFields(draftedFields);
            }
        } catch (err) {
            setError('Failed to load form details');
        } finally {
            setLoading(false);
        }
    };

    // ─── Actions ─────────────────────────────────────────

    const goToStep2 = () => {
        if (!formName.trim()) {
            setError('Form name is required');
            return;
        }
        if (!selectedTemplateId) {
            setError('Please select a template');
            return;
        }
        setError('');
        setStep(2);
    };

    const addField = () => {
        setFields((prev) => [
            ...prev,
            {
                id: nextFieldId++,
                label: '',
                data_type: 'text',
                required: false,
                placeholder_mapping: '',
                options_csv: '',
                format_options: null, // Initialize with null
            },
        ]);
    };

    const updateField = (id: number, key: keyof FieldDraft, value: string | boolean | FormatOptions | null) => {
        setFields((prev) =>
            prev.map((f) => (f.id === id ? { ...f, [key]: value } : f))
        );
    };

    const updateFormatOption = (fieldId: number, key: keyof FormatOptions, value: string | number | undefined) => {
        setFields((prev) =>
            prev.map((f) => {
                if (f.id === fieldId) {
                    const currentOptions = f.format_options || {};
                    const newOptions = { ...currentOptions, [key]: value || undefined };

                    // Remove undefined values to keep JSON clean
                    Object.keys(newOptions).forEach(k => {
                        if (newOptions[k as keyof FormatOptions] === undefined || newOptions[k as keyof FormatOptions] === '') {
                            delete newOptions[k as keyof FormatOptions];
                        }
                    });

                    // If no options left, set to null
                    return {
                        ...f,
                        format_options: Object.keys(newOptions).length > 0 ? newOptions : null
                    };
                }
                return f;
            })
        );
    };

    const removeField = (id: number) => {
        setFields((prev) => prev.filter((f) => f.id !== id));
    };

    const handleSave = async () => {
        setError('');
        // Validations
        if (fields.length === 0) {
            setError('At least one field is required');
            return;
        }
        for (const f of fields) {
            if (!f.label.trim()) {
                setError('All fields must have a label');
                return;
            }
            if (f.data_type === 'dropdown' && !f.options_csv.trim()) {
                setError(`Dropdown field "${f.label}" must have options`);
                return;
            }
        }
        // Unique mappings
        const mappings = fields.map((f) => f.placeholder_mapping).filter((m) => m !== '');
        const uniqueMappings = new Set(mappings);
        if (mappings.length !== uniqueMappings.size) {
            setError('Placeholder mappings must be unique across fields');
            return;
        }

        setSaving(true);
        try {
            const apiFields = fields.map((f) => ({
                label: f.label.trim(),
                field_key: f.field_key || toFieldKey(f.label),
                data_type: f.data_type,
                required: f.required,
                placeholder_mapping: f.placeholder_mapping || null,
                options_json:
                    f.data_type === 'dropdown' && f.options_csv
                        ? JSON.stringify(f.options_csv.split(',').map((o) => o.trim()).filter(Boolean))
                        : null,
                format_options: f.format_options ? JSON.stringify(f.format_options) : null, // NEW: Serialize format_options
            }));

            let result;
            if (editFormId) {
                await window.api.updateForm({
                    id: editFormId,
                    name: formName.trim(),
                    template_id: selectedTemplateId,
                    category_id: selectedCategoryId,
                    fields: apiFields
                });
                onSuccess();
            } else {
                const result = await window.api.createForm({
                    name: formName.trim(),
                    template_id: selectedTemplateId,
                    category_id: selectedCategoryId,
                    fields: apiFields
                });

                if (result.success) {
                    onSuccess();
                } else {
                    setError(result.error || 'Operation failed');
                }
            }
        } catch (err: unknown) {
            console.error('Save failed', err);
            setError(err instanceof Error ? err.message : 'An error occurred');
        } finally {
            setSaving(false);
        }
    };

    // ─── Render Formatting Section ──────────────────────

    const renderFormattingSection = (field: FieldDraft) => {
        const formatOpts = field.format_options || {};
        const showDateFormat = field.data_type === 'date';
        const showCurrency = field.data_type === 'currency';
        const showDecimals = field.data_type === 'number' || field.data_type === 'currency';
        const showTextTransform = field.data_type === 'text' || field.data_type === 'multiline';
        const showPrefixSuffix = true; // Available for all types

        // Don't show formatting section if no options are applicable
        if (!showDateFormat && !showCurrency && !showDecimals && !showTextTransform && !showPrefixSuffix) {
            return null;
        }

        return (
            <Accordion
                sx={{
                    mt: 1.5,
                    '&:before': { display: 'none' },
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&.Mui-expanded': { margin: '12px 0 0 0' }
                }}
            >
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{
                        minHeight: 40,
                        '&.Mui-expanded': { minHeight: 40 },
                        '& .MuiAccordionSummary-content': { margin: '8px 0' }
                    }}
                >
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <TuneIcon fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                            Formatting Options
                        </Typography>
                        {field.format_options && Object.keys(field.format_options).length > 0 && (
                            <Chip label="Active" size="small" color="primary" sx={{ height: 20 }} />
                        )}
                    </Box>
                </AccordionSummary>
                <AccordionDetails sx={{ pt: 1, pb: 2 }}>
                    <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 2 }}>
                        {/* Date Format */}
                        {showDateFormat && (
                            <TextField
                                select
                                label="Date Format"
                                value={formatOpts.dateFormat || 'DD-MM-YYYY'}
                                onChange={(e) => updateFormatOption(field.id, 'dateFormat', e.target.value as any)}
                                size="small"
                                fullWidth
                            >
                                {DATE_FORMATS.map((df) => (
                                    <MenuItem key={df.value} value={df.value}>{df.label}</MenuItem>
                                ))}
                            </TextField>
                        )}

                        {/* Currency Symbol */}
                        {showCurrency && (
                            <TextField
                                label="Currency Symbol"
                                value={formatOpts.currencySymbol || ''}
                                onChange={(e) => updateFormatOption(field.id, 'currencySymbol', e.target.value)}
                                size="small"
                                placeholder="₹, $, €"
                                inputProps={{ maxLength: 5 }}
                            />
                        )}

                        {/* Decimals */}
                        {showDecimals && (
                            <TextField
                                label="Decimal Places"
                                type="number"
                                value={formatOpts.decimals ?? ''}
                                onChange={(e) => updateFormatOption(field.id, 'decimals', e.target.value ? parseInt(e.target.value) : undefined)}
                                size="small"
                                inputProps={{ min: 0, max: 10 }}
                                placeholder="0-10"
                            />
                        )}

                        {/* Text Transform */}
                        {showTextTransform && (
                            <TextField
                                select
                                label="Text Transform"
                                value={formatOpts.transform || ''}
                                onChange={(e) => updateFormatOption(field.id, 'transform', e.target.value as any)}
                                size="small"
                                fullWidth
                            >
                                {TEXT_TRANSFORMS.map((tt) => (
                                    <MenuItem key={tt.value} value={tt.value}>{tt.label}</MenuItem>
                                ))}
                            </TextField>
                        )}

                        {/* Prefix */}
                        <TextField
                            label="Prefix"
                            value={formatOpts.prefix || ''}
                            onChange={(e) => updateFormatOption(field.id, 'prefix', e.target.value)}
                            size="small"
                            placeholder="e.g., INV-, Total:"
                            inputProps={{ maxLength: 20 }}
                        />

                        {/* Suffix */}
                        <TextField
                            label="Suffix"
                            value={formatOpts.suffix || ''}
                            onChange={(e) => updateFormatOption(field.id, 'suffix', e.target.value)}
                            size="small"
                            placeholder="e.g., %, /month"
                            inputProps={{ maxLength: 20 }}
                        />
                    </Box>

                    {/* Preview */}
                    {field.format_options && Object.keys(field.format_options).length > 0 && (
                        <Box sx={{ mt: 2, p: 1.5, bgcolor: alpha(theme.palette.primary.main, 0.05), borderRadius: 1 }}>
                            <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mb: 0.5 }}>
                                Preview (example):
                            </Typography>
                            <Typography variant="body2" sx={{ fontFamily: 'monospace' }}>
                                {getFormatPreview(field)}
                            </Typography>
                        </Box>
                    )}
                </AccordionDetails>
            </Accordion>
        );
    };

    const getFormatPreview = (field: FieldDraft): string => {
        const opts = field.format_options;
        if (!opts) return 'No formatting';

        let example = '';
        switch (field.data_type) {
            case 'date':
                example = opts.dateFormat === 'MM-DD-YYYY' ? '01-15-2024' :
                         opts.dateFormat === 'YYYY-MM-DD' ? '2024-01-15' : '15-01-2024';
                break;
            case 'currency':
                example = '1000';
                if (opts.currencySymbol) example = opts.currencySymbol + example;
                if (opts.decimals !== undefined) example = example + '.' + '0'.repeat(opts.decimals);
                break;
            case 'number':
                example = '1234';
                if (opts.decimals !== undefined) example = example + '.' + '5'.repeat(opts.decimals);
                break;
            case 'text':
            case 'multiline':
                example = 'Sample Text';
                if (opts.transform === 'uppercase') example = example.toUpperCase();
                if (opts.transform === 'lowercase') example = example.toLowerCase();
                break;
            default:
                example = 'value';
        }

        if (opts.prefix) example = opts.prefix + example;
        if (opts.suffix) example = example + opts.suffix;

        return example;
    };

    // ─── Render ──────────────────────────────────────────

    return (
        <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
            <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                {editFormId ? 'Edit Form' : 'Create Form'}
                <IconButton onClick={onClose}><CloseIcon /></IconButton>
            </DialogTitle>

            <DialogContent dividers>
                {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                        <CircularProgress />
                    </Box>
                ) : (
                    <Box>
                        {/* Progress Indicator */}
                        <Box sx={{ mb: 3, display: 'flex', justifyContent: 'center' }}>
                            <Chip label="1. Details" color={step === 1 ? 'primary' : 'default'} onClick={() => setStep(1)} sx={{ mr: 1, cursor: 'pointer' }} />
                            <Chip label="2. Fields" color={step === 2 ? 'primary' : 'default'} disabled={step === 1 && !editFormId} />
                        </Box>

                        {/* Auto-generation Banner */}
                        {autoGenerated && (
                            <Fade in>
                                <Alert severity="info" onClose={() => setAutoGenerated(false)} sx={{ mb: 2 }}>
                                    Fields auto-generated from template placeholders. Please review before saving.
                                </Alert>
                            </Fade>
                        )}

                        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

                        {step === 1 && (
                            <Box>
                                <TextField
                                    label="Form Name"
                                    value={formName}
                                    onChange={(e) => setFormName(e.target.value)}
                                    fullWidth required autoFocus sx={{ mb: 2.5 }}
                                />

                                <TextField
                                    select label="Template"
                                    value={selectedTemplateId}
                                    onChange={(e) => setSelectedTemplateId(e.target.value)}
                                    fullWidth required sx={{ mb: 2.5 }}
                                >
                                    {templates.map((t) => (
                                        <MenuItem key={t.id} value={t.id}>{t.name} ({t.placeholder_count} placeholders)</MenuItem>
                                    ))}
                                </TextField>

                                <Typography variant="caption" sx={{ mb: 1, display: 'block' }}>Category (Optional)</Typography>
                                <Box sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 1, height: 200, overflow: 'auto', mb: 2 }}>
                                    <CategoryTree
                                        type="FORM"
                                        selectedCategoryId={selectedCategoryId}
                                        onSelectCategory={setSelectedCategoryId}
                                        readOnly
                                        refreshTrigger={0}
                                    />
                                </Box>
                            </Box>
                        )}

                        {step === 2 && (
                            <Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                                    <Typography variant="subtitle1">Form Fields</Typography>
                                    <Button startIcon={<AddIcon />} variant="outlined" size="small" onClick={addField}>Add Field</Button>
                                </Box>

                                {fields.length === 0 && <Alert severity="info">Add at least one field.</Alert>}

                                {fields.map((field, index) => (
                                    <Paper key={field.id} sx={{ p: 2, mb: 1.5, border: `1px solid ${theme.palette.divider}` }} elevation={0}>
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                            <Typography variant="body2" sx={{ fontWeight: 600 }}>Field {index + 1}</Typography>
                                            <IconButton size="small" color="error" onClick={() => removeField(field.id)}><DeleteIcon fontSize="small" /></IconButton>
                                        </Box>
                                        <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 2, my: 1 }}>
                                            <TextField label="Label" value={field.label} onChange={e => updateField(field.id, 'label', e.target.value)} size="small" required />
                                            <TextField select label="Type" value={field.data_type} onChange={e => updateField(field.id, 'data_type', e.target.value)} size="small">
                                                {FIELD_TYPES.map(t => <MenuItem key={t.value} value={t.value}>{t.label}</MenuItem>)}
                                            </TextField>
                                        </Box>
                                        <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                                            <TextField select label="Map to Placeholder" value={field.placeholder_mapping} onChange={e => updateField(field.id, 'placeholder_mapping', e.target.value)} size="small" sx={{ flexGrow: 1 }}>
                                                <MenuItem value=""><em>None</em></MenuItem>
                                                {placeholders.map(p => <MenuItem key={p.id} value={p.placeholder_key}>{`{{${p.placeholder_key}}}`}</MenuItem>)}
                                            </TextField>
                                            <FormControlLabel control={<Switch checked={field.required} onChange={e => updateField(field.id, 'required', e.target.checked)} size="small" />} label="Required" />
                                        </Box>
                                        {field.data_type === 'dropdown' && (
                                            <TextField label="Options (comma-separated)" value={field.options_csv} onChange={e => updateField(field.id, 'options_csv', e.target.value)} size="small" fullWidth sx={{ mt: 1 }} />
                                        )}

                                        {/* NEW: Formatting Section */}
                                        {renderFormattingSection(field)}
                                    </Paper>
                                ))}
                            </Box>
                        )}
                    </Box>
                )}
            </DialogContent>

            <DialogActions>
                {step === 2 && <Button onClick={() => setStep(1)} startIcon={<BackIcon />}>Back</Button>}
                <Box sx={{ flexGrow: 1 }} />
                <Button onClick={onClose}>Cancel</Button>
                {step === 1 ? (
                    <Button variant="contained" onClick={goToStep2} disabled={loading}>Next</Button>
                ) : (
                    <Button variant="contained" onClick={handleSave} disabled={saving} startIcon={<SaveIcon />}>
                        {editFormId ? 'Update Form' : 'Create Form'}
                    </Button>
                )}
            </DialogActions>
        </Dialog>
    );
};

export default FormWizard;
